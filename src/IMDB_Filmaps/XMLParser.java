package IMDB_Filmaps;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.charset.Charset;
import java.nio.charset.CharsetEncoder;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Scanner;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;

import org.xml.sax.Attributes;
import org.xml.sax.SAXException;
import org.xml.sax.helpers.DefaultHandler;

/**
 * XML Parser of filmaps xml OR IMDB xml file generated by IMDBGeoCoding
 * 
 * @author Yoav
 * 
 */
public class XMLParser extends DefaultHandler {

	private static boolean isValid(String input) {
		return encoder.canEncode(input);
	}

	private List<Movie> myMovies;
	
	private String tempVal;


	private String city;
	private String country;
	private Movie tempMov;
	private Location tempLoc;
	private File f;
	private Scanner in = null;
	private int numLocations = 0;
	private int numMovies = 0;
	private int numFilmMapsParsed=0;
	private static CharsetEncoder encoder = Charset.forName("US-ASCII")
			.newEncoder();
	private boolean isIMDB;
	private String filePath;

	private int limit;
	/**
	 * 
	 * @param connect
	 *            Connection to DB
	 * @param isIMDB
	 *            true = will parse xml genreated by IMDBGeoCoding, false = will
	 *            parse filmaps xml files
	 * @param filePath
	 *            xml file of IMDB locations or locations.list of filmaps
	 * @param limit only used for filmaps ! number of locations xml pages to parse
	 */
	public XMLParser(boolean isIMDB, String filePath,int limit) {
		myMovies = new ArrayList<Movie>();
		this.isIMDB = isIMDB;
		this.filePath = filePath;
		this.limit=limit;
	}
	public void characters(char[] ch, int start, int length)
			throws SAXException {
		tempVal = new String(ch, start, length);
	}

	public void endElement(String uri, String localName, String qName)
			throws SAXException {

		if (qName.equalsIgnoreCase("movie")) {
			// add it to the list
			myMovies.add(tempMov);
		} else if (qName.equalsIgnoreCase("title")) {
			tempMov.setTitle(tempVal.trim());
		} else if (qName.equalsIgnoreCase("poster")) {
			tempMov.setPoster(tempVal);
		} else if (qName.equalsIgnoreCase("location")) {
			tempLoc.setCity(city);
			tempLoc.setCountry(country);
			tempMov.getLocations().add(tempLoc);
		} else if (qName.equalsIgnoreCase("place")) {
			String place = splitLocation(tempVal);
			tempLoc.setPlace(place);
		} else if (qName.equalsIgnoreCase("scene")) {
			tempLoc.setScene(tempVal);
		} else if (qName.equalsIgnoreCase("coordinates")) {
			int comma = tempVal.indexOf(",");
			if (!isIMDB)
				tempVal = tempVal.substring(comma + 1) + ","
						+ tempVal.substring(0, comma);
			else
				tempVal = tempVal.substring(0, comma) + ","
						+ tempVal.substring(comma + 1);
			tempLoc.setCoordinates(tempVal);
		}

	}

	public List<Movie> getMyMovies() {
		return myMovies;
	}

	public int getStatus(){
		if(isIMDB)
			return numMovies;
		return numFilmMapsParsed;
	}

	/**
	 * Iterate through the list and print the contents
	 */
	public void printData() {
		Iterator<Movie> it = this.myMovies.iterator();
		while (it.hasNext()) {
			System.out.println(it.next().toString());
		}
	}

	@SuppressWarnings("unchecked")
	public boolean RestoreMovieList() throws IOException,
			ClassNotFoundException {
		Object obj = null;

		FileInputStream f_in;
		// Read from disk using FileInputStream
		if (!isIMDB)
			f_in = new FileInputStream("Filmaps\\Filmaps.data");
		else
			f_in = new FileInputStream("IMDB\\IMDB.data");

		// Read object using ObjectInputStream
		ObjectInputStream obj_in = new ObjectInputStream(f_in);

		// Read an object
		obj = obj_in.readObject();
		
		obj_in.close();

		if (obj instanceof List) {
			myMovies = (List<Movie>) obj;
			return true;
		}
		return false;
	}

	public boolean run() throws ParserConfigurationException, SAXException,
			IOException {
		if (isIMDB) {
			f = new File(filePath);
			if(parseIMDBFile())
			{
				System.out.println("Number of Locations Parsed: " + numLocations);
				SerializeMovieList("IMDB\\IMDB.data");
				return true;
			}
			return false;
		} else {
			System.out
					.println("IMPORTANT: a full Filmaps XML parsing takes at least 60 minutes and must not be interrupted until completion.\nPress any key to start parsing...");
			System.in.read();
			f = new File(filePath);
			in = new Scanner(new FileReader(f));
			parseFilmMaps();
			System.out.println("Number of Locations Parsed: " + numLocations);
			if(numLocations>0)
				SerializeMovieList("Filmaps\\Filmaps.data");
			else
				return false;			
			return true;
		}
		
	}

	// Event Handlers
	public void startElement(String uri, String localName, String qName,
			Attributes attributes) throws SAXException {
		// reset
		tempVal = "";
		if (qName.equalsIgnoreCase("movie")) {
			// create a new instance of movie
			tempMov = new Movie();
			numMovies++;
		} else if (qName.equalsIgnoreCase("location")) {
			// create a new instance of movie
			tempLoc = new Location();
			numLocations++;
		}
	}

	private String getNextLocation() {
		if (in.hasNextLine()) {
			String l = in.nextLine();
			String[] loc = l.split("\t");
			if (loc.length == 3) {
				city = loc[0];
				String location = loc[1];
				country = loc[2];
				if (isValid(location) && isValid(city) && isValid(country))
					return location;
				else
					return "error";
			} else
				return "error";
		} else
			return null;
	}

	private void parseFilmMaps() throws ParserConfigurationException,
			SAXException {
		// get a factory
		SAXParserFactory spf = SAXParserFactory.newInstance();

		// get a new instance of parser
		SAXParser sp = spf.newSAXParser();

		// parse the file and also register this class for call backs
		String location = getNextLocation();
		
		while (location != null && numFilmMapsParsed <=limit) {			
			if (!location.equals("error") && encoder.canEncode(location)) {
				try {
					sp.parse("http://www.filmaps.com/xml/?loc=" + location,
							this);
				} catch (Exception e) {
				}
				numFilmMapsParsed++;
			}
			location = getNextLocation();
		}
	}

	private boolean parseIMDBFile() throws ParserConfigurationException,
			SAXException {
		SAXParserFactory spf = SAXParserFactory.newInstance();

		// get a new instance of parser
		SAXParser sp = spf.newSAXParser();

		try {
			sp.parse(f, this);
		} catch (Exception e) {
			System.out.println("error parsing imdb xml file");
			return false;
		}
		return true;
	}

	private void SerializeMovieList(String name) throws IOException {

		// Write to disk with FileOutputStream
		FileOutputStream f_out = new FileOutputStream(name);

		// Write object with ObjectOutputStream
		ObjectOutputStream obj_out = new ObjectOutputStream(f_out);

		// Write object out to disk
		obj_out.writeObject(myMovies);
		obj_out.close();

	}
	private String splitLocation(String location) {
		String place = "";
		String[] splitedLocation = new String[10];
		String[] locations = location.split(", ");

		for (int i = 0; i < locations.length; i++) {
			if (isValid(locations[i]))
				splitedLocation[i] = locations[i];
			else
				splitedLocation[i] = "";
		}
		if (locations.length == 0) {
			place = location;
			city = "";
			country = "";
		} else if (locations.length == 1) {
			place = splitedLocation[0];
			city = "";
			country = "";
		} else if (locations.length == 2) {
			place = "";
			city = splitedLocation[0];
			country = splitedLocation[1];
		} else {
			place = splitedLocation[0];
			for (int i = 1; i < locations.length - 2; i++) {
				if (splitedLocation[i] != null)
					if (!splitedLocation[i].equals(""))
						place += "," + splitedLocation[i];
			}
			city = splitedLocation[locations.length - 2];
			country = splitedLocation[locations.length - 1];
		}

		return place;
	}

}
